# Спецификация ConstantFolder

## Обзор

`ConstantFolder` — статический проход-оптимизатор, выполняющий **constant folding** по AST. Принимает `Program`, возвращает новый `Program`, в котором выражения, вычислимые на этапе компиляции, заменены на соответствующие литералы.

**Интерфейс:**
```kotlin
object ConstantFolder {
    fun fold(program: Program): Program
}
```

## Поддерживаемые преобразования

### 1. Литералы
`LiteralExpr` — не изменяется.

### 2. Унарные операторы
`-`, `+`, `!` — если операнд свёлся к литералу, результат вычисляется и возвращается как `LiteralExpr`.

### 3. Бинарные операторы

**Арифметика:** `+`, `-`, `*`, `/`, `%`
- Если оба операнда — литералы, выполняется вычисление
- Для `Long`/`Long` результат `Long`, за исключением `/`, когда результат нецелый — `Double`
- Для смешанных типов/Double — результат `Double`
- Деление и остаток на ноль **не выполняются** — фолдинг отменяется

**Логика и сравнения:** `&&`, `||`, `==`, `!=`, `<`, `<=`, `>`, `>=`
- Если оба операнда — литералы, выполняется вычисление, результат — `LiteralExpr(Boolean)`
- Для `&&`/`||` реализованы упрощения: `true || x` → `true`, `false && x` → `false`

### 4. Группировка
Если вложенное выражение свернуто в литерал, группировка удаляется.

### 5. Вызовы
Аргументы сворачиваются рекурсивно. Сам вызов не выполняется.

### 6. Массивы
`ArrayInitExpr.size` сворачивается, если возможно.

### 7. Присваивания
Значение (`value`) сворачивается. Если целевой `LValue` — `ArrayAccessExpr`, то его `array` и `index` сворачиваются.

### 8. Операторы
`VarDecl`, `ReturnStmt`, `ExprStmt`, `FunctionDecl`, `BlockStmt`, `ForStmt`, `IfStmt` — рекурсивно обрабатываются.

**IfStmt с константным условием:** заменяется на соответствующую ветвь (`thenBranch` или `elseBranch`).

## Семантические детали

- **Иммутабельность:** исходный AST не мутируется — создаётся новый `Program`
- **Типы литералов:** целые — `Long`, числа с плавающей точкой — `Double`, булевы — `Boolean`
- **Деление на ноль:** проверяется точное равенство на ноль, при нуле фолдинг отменяется
- **Обработка ошибок:** при `ArithmeticException` возвращается исходный `BinaryExpr`

## Примеры

- `x = 2 + 3` → `x = 5`
- `a = 5 / 2` → `a = 2.5` (Double)
- `b = 4 / 2` → `b = 2` (Long)
- `x = 1 / 0` → остаётся `BinaryExpr(1 / 0)` (фолдинг не выполняется)
- `y = -(5)` → `y = -5`
- `b = true || foo()` → `b = true`
- `if (true) { ... } else { ... }` → заменяется на `then`-блок
- `arr = int[1 + 2]` → `arr = int[3]`
