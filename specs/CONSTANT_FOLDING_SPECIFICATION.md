# Спецификация `ConstantFolder`

## Обзор

`ConstantFolder` — статический проход-оптимизатор, выполняющий **constant folding** по AST.
Реализован как иммутабельный пост-обход дерева: принимает `Program`, возвращает новый `Program`, в котором выражения, вычислимые на этапе компиляции, заменены на соответствующие литералы.

**Цели:** уменьшить объём вычислений на рантайме, упростить дальнейшие оптимизации и генерацию кода.

# Интерфейс

```kotlin
package com.compiler.parser.ast.optimizations

object ConstantFolder {
    fun fold(program: Program): Program
}
```

`fold` — единственная публичная точка входа. Возвращает новый `Program` с применёнными свёртками.

# Поддерживаемые преобразования

1. **Литералы**
   * `LiteralExpr` — не изменяется.

2. **Унарные операторы**
   * `-`, `+`, `!` (`TokenType.MINUS`, `TokenType.PLUS`, `TokenType.NOT`):
     * Если операнд свёлся к литералу (Long/Double/Boolean), результат вычисляется и возвращается как `LiteralExpr`.
     * Иначе возвращается `UnaryExpr` с уже свернутым операндом.

3. **Бинарные операторы**

   * Арифметика: `+`, `-`, `*`, `/`, `%`:
     * Поддерживаются операнды `Long` и `Double`.
     * Если оба операнда — литералы, выполняется вычисление:
       * Для `Long`/`Long` результат сохраняется как `Long`, за исключением `/`, когда результат нецелый — `Double`.
       * Для смешанных типов/Double — результат `Double`.
     * Деление и остаток на ноль **не выполняются**: в таких случаях фолдинг отменяется (возвращается исходный `BinaryExpr`).
   * Логика и сравнения: `&&`, `||`, `==`, `!=`, `<`, `<=`, `>`, `>=`:
     * Если оба операнда — литералы, выполняется вычисление и результат — `LiteralExpr(Boolean)`.
     * Для `&&`/`||` реализованы дополнительные упрощения: если левый операнд — булевый литерал и решает результат (`true || x` → `true`, `false && x` → `false`), то результат подставляется. (В текущей реализации правый операнд предварительно вычисляется; уточнения по оптимизации см. раздел «Ограничения/поведение».)

4. **Группировка (`GroupingExpr`)**
   * Если вложенное выражение свершено в литерал, то групировка удаляется (возвращается литерал). Иначе возвращается `GroupingExpr` с свернутым содержимым.

5. **Вызовы (`CallExpr`)**
   * Аргументы сворачиваются рекурсивно.
   * Сам вызов не выполняется — `CallExpr` остаётся, но с уже свернутыми аргументами.

6. **Индексация и инициализация массивов**
   * `ArrayInitExpr.size` сворачивается, если возможно.
   * `ArrayAccessExpr.index` и `array` сворачиваются рекурсивно (но сам доступ не вычисляется).

7. **Присваивания (`AssignExpr`)**
   * Значение (`value`) сворачивается.
   * Если целевой `LValue` — `ArrayAccessExpr`, то его `array` и `index` сворачиваются. `VariableExpr` как цель не изменяется.

8. **Операторы-уровня блока и объявления**
   * `VarDecl`, `ReturnStmt`, `ExprStmt`, `FunctionDecl`, `BlockStmt`, `ForStmt`, `IfStmt` — рекурсивно обрабатываются: все вложенные выражения и блоки подвергаются фолдингу.
   * `IfStmt` с константным условием заменяется на соответствующую ветвь: `thenBranch` или `elseBranch` (или пустой блок, если `else` отсутствует и условие — `false`).

# Семантические детали и ограничения

* **Иммутабельность:** исходный AST не мутируется — создаётся новый `Program` и новые узлы там, где это требуется.
* **Типы литералов:** целые — `Long`, числа с плавающей точкой — `Double`, булевы — `Boolean`. `LiteralExpr.value` может быть `Any?`.
* **Деление `/` и `%`:**
  * Проверяется точное равенство на ноль (`isZero`): `Long == 0L` или `Double == 0.0`. При точном нуле фолдинг отменяется (чтобы избежать исключения/потенциально неопределённого поведения).
  * Мелкие (≈0) ненулевые Double будут использоваться в вычислении (текущая логика не вводит эпсилон).
* **Сравнение чисел (`numericEq`, `numericCompare`):**
  * Приведение к `Double` через `toDouble` и последующее сравнение (`==`/`compareTo`).
  * Следствия:
    * `Double.NaN == Double.NaN` → `false` (в текущей реализации).
    * `-0.0 == 0.0` → `true`.
  * Если требуется другая семантика (битовая эквивалентность), следует заменить реализацию на сравнение битов (`Double.doubleToLongBits`) — в текущей реализации такое поведение **не** предпринято, но должно быть явно задокументировано.
* **Позиции (`SourcePos`):**
  * При разворачивании литерала код возвращает сам `LiteralExpr` (т.е. сохранится `pos` внутреннего литерала). Группировка при упрощении возвращает `inner` — позиция исходных скобок при этом **не** сохраняется. Если требуется сохранять позицию группировки, необходимо создавать новый `LiteralExpr(inner.value, expr.pos)`.
* **Ленивая свёртка логических `AND/OR`:**
  * Текущая реализация сначала сворачивает оба операнда, затем применяет правила упрощения. Это корректно, но менее оптимально: возможно лишняя работа по свёртке правого операнда, когда левый литерал уже решает результат.
* **Обработка ошибок:** при обнаружении арифметических проблем (деление на ноль) `ArithmeticException` перехватывается и в этом случае возвращается исходный `BinaryExpr` (откат).

# Алгоритм (описание работы)

1. `fold(program: Program)` — итерирует `program.statements`, вызывает `foldStatement`.
2. `foldStatement(stmt)` — pattern-match по типу `Statement`:
   * Для деклараций/блоков/инструкций рекурсивно вызывает соответствующие `fold*` методы.
3. `foldExpression(expr)` — pattern-match по типу `Expression`:
   * Для `LiteralExpr` — возвращает как есть.
   * Для составных выражений — рекурсивно сворачивает дочерние узлы и, при возможности, вычисляет значение (для унарных/бинарных операций).
4. При вычислении бинарных/унарных операций:
   * Если оба (или один, для унарных) операнда — литералы -> выполнить операцию со строгой типовой логикой (см. раздел «Поддерживаемые преобразования»).
   * В случае ошибок (деление/остаток на ноль) — не сворачивать и вернуть исходный узел с уже свернутыми детьми.

# Примеры (input → output)

* `x = 2 + 3` → `x = 5`
* `a = 5 / 2` → `a = 2.5` (Double)
* `b = 4 / 2` → `b = 2` (Long)
* `x = 1 / 0` → остаётся `BinaryExpr(1 / 0)` (фолдинг не выполняется)
* `y = -(5)` → `y = -5`
* `b = true || foo()` → `b = true` (правый аргумент может быть свернут, но вызов `foo()` не выполняется)
* `if (true) { ... } else { ... }` → заменяется на `then`-блок
* `arr = int[1 + 2]` → `arr = int[3]`; `arr[1 + 2]` → `arr[3]`
* `r = f(1 + 2)` → `r = f(3)` (аргументы свернуты, вызов не выполняется)

# Пример использования (Kotlin)

```kotlin
val program: Program = ... // AST, полученный парсером
val optimized: Program = ConstantFolder.fold(program)
```

