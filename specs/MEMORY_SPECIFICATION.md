# Спецификация: модуль памяти (Heap + Reference Counting GC) для VM

## 1. Обзор

Данный документ описывает модуль памяти для стековой виртуальной машины, совместимый с текущей спецификацией байткода.

Модуль памяти отвечает за:
- хранение динамически выделяемых объектов (куча / Heap);
- управление временем жизни объектов по алгоритму **Reference Counting** (подсчёт ссылок);
- предоставление API для инструкций, работающих с кучей (создание массивов, доступ по индексу).

Требования:
- максимально простая реализация;
- без сложных оптимизаций (compaction, generations и т.п.);
- корректная работа для текущих типов объектов (массивы примитивов).

Ограничение Reference Counting:
- RC не собирает циклы ссылок. В текущей версии это допустимо, т.к. в куче есть только массивы примитивов (`int[]`, `float[]`) и циклы невозможны.

---

## 2. Термины и сущности

- Value: значение в VM (лежит на operand stack и/или в locals).
- ArrayRef(heapId): ссылочное значение на объект в куче.
- Heap: хранилище объектов по `heapId`.
- HeapObject: объект в куче с `refCount`.
- Root owners: владельцы ссылок, которые считаются корнями (operand stack, locals, globals если есть).
- retain: увеличить счётчик ссылок.
- release: уменьшить счётчик ссылок и освободить объект при достижении 0.

---

## 3. Представление значений (Value)

VM использует единый тип `Value` для стека и локалов. Для памяти важен только ссылочный вариант:

- `ArrayRef(heapId: Int)` — ссылка на объект в куче.

Примитивы (`IntValue`, `FloatValue`, `BoolValue`, `VoidValue`) не участвуют в GC и не имеют refCount.

---

## 4. Heap (куча)

### 4.1 Назначение
Heap хранит все динамически выделяемые объекты и выдаёт им идентификаторы `heapId`.

### 4.2 Инварианты heapId
- `heapId` — целое положительное число.
- `heapId` уникален в рамках одного `Heap`.
- `ArrayRef(heapId)` считается валидным только если объект существует в heap.

### 4.3 Типы объектов в куче (текущая версия)
Поддерживаются только массивы примитивов:
- `int[]`  (хранит `LongArray`)
- `float[]` (хранит `DoubleArray`)

Каждый объект содержит:
- `refCount: Int` — счётчик ссылок (владельцев).
- данные массива.

### 4.4 Семантика аллокации
Операции:
- `allocIntArray(size)` создаёт массив длины `size`, заполняет нулями, регистрирует объект в heap.
- `allocFloatArray(size)` создаёт массив длины `size`, заполняет нулями, регистрирует объект в heap.

Требования:
- `size >= 0` иначе ошибка выполнения.
- После `alloc*` объект существует в heap с `refCount = 0`.
- Поднятие `refCount` — ответственность GC/MemoryManager через `retain`.

### 4.5 Семантика освобождения
Операция:
- `free(heapId)` удаляет объект из heap.

Требования:
- повторный `free` или `free` несуществующего id считается ошибкой выполнения - сразу падаем с ошибкой.

---

## 5. Reference Counting GC

### 5.1 Назначение
GC ведёт подсчёт ссылок на heap-объекты и освобождает объект, когда `refCount` достигает 0.

### 5.2 Операции
- `retain(value)`:
    - если `value` = `ArrayRef(id)` → `heap[id].refCount++`
    - иначе no-op

- `release(value)`:
    - если `value` = `ArrayRef(id)` → `heap[id].refCount--`
    - если `refCount` стал 0 → `free(id)`
    - если `refCount` стал отрицательным → ошибка выполнения
    - если `id` не существует → ошибка выполнения

### 5.3 Инвариант времени жизни
- Объект может существовать в heap только если `refCount > 0`.
- Освобождение происходит немедленно при переходе `refCount: 1 -> 0`.
---

## 6. MemoryManager (уровень VM)

### 6.1 Назначение
MemoryManager объединяет Heap и GC и предоставляет высокоуровневые операции, необходимые интерпретатору инструкций.

### 6.2 API MemoryManager (минимально необходимое)

- `newIntArray(size: Int): ArrayRef`
    - создаёт массив в heap
    - возвращает `ArrayRef(id)` с **refCount = 1** (владение передано вызывающему коду VM)

- `newFloatArray(size: Int): ArrayRef`
    - аналогично, refCount = 1

- `intArrayLoad(ref: ArrayRef, index: Int): Long`
- `intArrayStore(ref: ArrayRef, index: Int, value: Long)`
- `floatArrayLoad(ref: ArrayRef, index: Int): Double`
- `floatArrayStore(ref: ArrayRef, index: Int, value: Double)`

- `retain(value: Value)`
- `release(value: Value)`

### 6.3 Bounds-check для массивов
По спецификации VM выход за границы массива приводит к падению VM.

Требования:
- `index < 0` или `index >= size` → ошибка выполнения.

---

## 7. Правила владения (ownership) для корректного RC

RC корректен только если VM соблюдает правила, когда нужно `retain` и когда нужно `release`.

### 7.1 Где хранятся "корни" (root owners)
Владельцами ссылок считаются:
- operand stack;
- locals в call frame;
- глобальные переменные (если/когда появятся).

### 7.2 Copy vs Move
- Copy (копирование ссылки): появляется новый владелец → нужно `retain`.
- Move (перемещение владения): владелец меняется, но общее число владельцев не растёт → `retain` не нужен.

---

## 8. Интеграция с инструкциями байткода

Ниже указано, какие инструкции обязаны взаимодействовать с MemoryManager (retain/release).

### 8.1 NEW_ARRAY_INT (0x90)
Стек: `..., int_size → ..., array_ref`

Алгоритм:
1) снять `int_size` со стека (move);
2) `array_ref = memory.newIntArray(size)` (возвращает refCount=1);
3) положить `array_ref` на стек (move).

### 8.2 NEW_ARRAY_FLOAT (0x91)
Аналогично `NEW_ARRAY_INT`.

### 8.3 ARRAY_LOAD (0x92)
Стек: `..., array_ref, int_index → ..., element_value`

Для массивов примитивов:
- никаких retain/release не происходит.

### 8.4 ARRAY_STORE (0x93)
Стек: `..., array_ref, int_index, value → ...`

Для массивов примитивов:
- никаких retain/release не происходит.

---

## 9. Правила RC для базовых VM-операций со стеком и локалами

Эти правила относятся не к модулю памяти напрямую, но обязательны для корректной работы reference counting.

### 9.1 LOAD_LOCAL (0x10)
Семантика: значение из locals копируется на operand stack.

RC-правило:
- это Copy → если значение `ArrayRef`, нужно `retain` перед помещением на стек.

### 9.2 STORE_LOCAL (0x11)
Семантика: значение снимается со стека и записывается в local slot.

RC-правило:
- это Move из стека в locals → `retain` не нужен;
- но если в `locals[i]` было старое значение, его нужно `release` перед заменой.

### 9.3 POP (0x04)
Семантика: снять верх стека и выбросить.

RC-правило:
- удаляем владельца со стека → `release` значения.

### 9.4 CALL (0x80)
Аргументы снимаются со стека и записываются в locals нового фрейма.

RC-правило:
- это Move (из стека вызывающего в locals вызываемого) → retain не нужен;
- стек теряет владение (popMove), locals получают владение.

### 9.5 RETURN (0x81)
Значение возвращается вызывающей функции (обычно кладётся на стек вызывающего).

RC-правило:
- это Move: значение выходит из текущего фрейма и становится владельцем у стека вызывающего;
- retain не нужен.

### 9.6 Завершение фрейма
При выходе из функции (RETURN/RETURN_VOID) VM должна освободить все локалы текущего фрейма:
- пройти по `locals[]` и выполнить `release` для всех `ArrayRef` значений.

---

## 10. Ошибки выполнения (memory module)

Модуль памяти должен приводить к падению VM при следующих ситуациях:
- `release` несуществующего `heapId`;
- `release`, приводящий к `refCount < 0`;
- двойной `free`;
- выход за границы массива при `ARRAY_LOAD/ARRAY_STORE`;
- отрицательный размер массива при `NEW_ARRAY_*`.
