# Спецификация JIT компилятора

## Обзор

JIT (Just-In-Time) компилятор динамически компилирует "горячие" функции в JVM bytecode для ускорения выполнения. JIT работает совместно с виртуальной машиной (см. `VM_SPECIFICATION.md`), автоматически определяя функции, которые вызываются часто, и компилируя их в оптимизированный код.

## Архитектура JIT компилятора

### Компоненты

JIT компилятор состоит из следующих основных компонентов:

```kotlin
class JITCompiler(
    private val module: BytecodeModule,
    private val threshold: Int = 1000
) {
    private val callCounts: ConcurrentHashMap<String, AtomicInteger>
    private val compiledFunctions: ConcurrentHashMap<String, CompiledFunctionExecutor>
    private val bytecodeGenerator: JVMBytecodeGenerator
}
```

### Интерфейс

JIT компилятор реализует интерфейс для интеграции с VM:

```kotlin
interface JITCompilerInterface {
    /**
     * Записать вызов функции для профилирования.
     * Вызывается VM при каждом CALL.
     */
    fun recordCall(functionName: String)
    
    /**
     * Получить скомпилированную версию функции, если она готова.
     * Возвращает null, если функция еще не скомпилирована.
     */
    fun getCompiled(functionName: String): CompiledFunctionExecutor?
    
    /**
     * Проверить, включен ли JIT.
     */
    fun isEnabled(): Boolean
}
```

### Структуры данных

#### CompiledJVMFunction

Результат компиляции функции:

```kotlin
data class CompiledJVMFunction(
    val clazz: Class<*>,      // Загруженный класс с JVM bytecode
    val method: Method        // Метод execute через reflection
) : CompiledFunctionExecutor {
    override fun execute(
        frame: CallFrame,
        stack: RcOperandStack,
        mm: MemoryManager
    ): VMResult {
        return method.invoke(null, frame, stack, mm) as VMResult
    }
}
```

## Профилирование

### Механизм профилирования

JIT компилятор отслеживает количество вызовов каждой функции:

**Алгоритм:**
1. При каждом вызове функции VM вызывает `recordCall(functionName)`
2. Увеличивается счетчик вызовов для этой функции (thread-safe через `AtomicInteger`)
3. Если счетчик достиг порога (`threshold`) и функция еще не скомпилирована:
   - Запускается асинхронная компиляция функции

**Порог компиляции:** По умолчанию 1000 вызовов. Функция считается "горячей" после достижения порога.

### Thread-safety

Профилирование использует thread-safe структуры данных:
- `ConcurrentHashMap` для счетчиков вызовов
- `AtomicInteger` для атомарного инкремента

Это позволяет безопасно профилировать в многопоточной среде (если VM будет многопоточной в будущем).

## Компиляция

### Асинхронная компиляция

Компиляция выполняется асинхронно в отдельном потоке, чтобы не блокировать выполнение программы.

**Алгоритм:**
1. Найти функцию по имени в модуле
2. Запустить компиляцию в отдельном потоке
3. При успешной компиляции сохранить результат в `compiledFunctions`
4. При ошибке компиляции логировать в stderr, но не прерывать выполнение программы

**Преимущества асинхронной компиляции:**
- Не блокирует выполнение программы
- Позволяет продолжать интерпретацию во время компиляции
- Ошибки компиляции не приводят к падению программы

### Защита от двойной компиляции

Для предотвращения одновременной компиляции одной функции используется синхронизация:
- Используется `ConcurrentHashMap` для хранения locks по имени функции
- Перед запуском компиляции выполняется двойная проверка (double-check locking):
  1. Проверить наличие lock для функции
  2. В synchronized блоке проверить, не скомпилирована ли уже функция
  3. Только если не скомпилирована → запустить компиляцию

## JVM Bytecode Generator

### Обзор

Генератор транслирует наш байткод в JVM bytecode через библиотеку ASM.

**Процесс компиляции:**
1. **Генерация JVM bytecode:** Трансляция инструкций нашего байткода в JVM bytecode через ASM API
2. **Загрузка класса:** Использование `ByteArrayClassLoader` для загрузки сгенерированного класса в JVM
3. **Получение метода:** Через reflection получить метод `execute` с сигнатурой `(CallFrame, RcOperandStack, MemoryManager) -> VMResult`
4. **Возврат результата:** Обернуть в `CompiledJVMFunction` для использования VM

### Генерация класса

**Структура класса:**
- Имя класса: `Generated_<functionName>` (с заменой точек на подчеркивания и добавлением timestamp для уникальности)
- Модификаторы: `public final`
- Наследование: `java.lang.Object`
- Метод: `public static execute(CallFrame, RcOperandStack, MemoryManager): VMResult`

**Использование ASM:**
- `ClassWriter(COMPUTE_FRAMES)` для автоматического вычисления frame stack
- `visit()` для определения класса
- `visitMethod()` для создания метода
- `visitEnd()` для завершения генерации

### Генерация метода execute

**Структура метода:**
1. Начало метода (`visitCode()`)
2. Трансляция всех инструкций функции
3. Возврат `VMResult.SUCCESS` в конце метода
4. Завершение метода (`visitEnd()`)

**Сигнатура метода:**
- `public static`
- Параметры: `CallFrame`, `RcOperandStack`, `MemoryManager`
- Возвращаемый тип: `VMResult`

## Трансляция инструкций

### Общий алгоритм

Трансляция выполняется в два прохода:

**Первый проход: создание меток для JUMP**
- Проход по всем инструкциям
- Для инструкций `JUMP`, `JUMP_IF_FALSE`, `JUMP_IF_TRUE`:
  - Вычислить адрес цели перехода
  - Создать `Label` для этого адреса
  - Сохранить в map для использования во втором проходе

**Второй проход: генерация кода**
- Проход по всем инструкциям
- Для каждой инструкции:
  - Если есть метка для текущего адреса → добавить её через `visitLabel()`
  - Прочитать opcode и operand
  - Вызвать соответствующий метод трансляции
- Каждая инструкция транслируется в последовательность JVM bytecode инструкций

### Примеры трансляции

#### PUSH_INT

**Трансляция:**
1. Получить константу из `module.intConstants[operand]`
2. Загрузить константу на стек JVM через `visitLdcInsn()` (LDC инструкция)
3. Вызвать статический метод `Value.IntValue.box(long)` для создания объекта
4. Загрузить локальную переменную `stack` (ALOAD 1)
5. Вызвать виртуальный метод `RcOperandStack.pushMove(Value)`

**Результат:** Константа помещена на наш operand stack.

#### ADD_INT

**Трансляция:**
1. Получить второе значение (b):
   - Загрузить `stack` (ALOAD 1)
   - Вызвать `popMove()` → получить `Value`
   - Привести к `Value.IntValue` (CHECKCAST)
   - Вызвать `getValue()` → получить `long` на стеке JVM
2. Получить первое значение (a) аналогично
3. Выполнить сложение через `LADD` (JVM инструкция для long)
4. Создать `IntValue` через `box(long)`
5. Вызвать `stack.pushMove(IntValue)`

**Результат:** Сумма помещена на наш operand stack.

#### JUMP_IF_FALSE

**Трансляция:**
1. Получить bool значение со стека:
   - Загрузить `stack` и вызвать `popMove()`
   - Привести к `Value.BoolValue` и вызвать `getValue()` → получить `boolean` на стеке JVM
2. Вычислить адрес цели перехода: `targetPC = currentPC + (operand * 4)`
3. Получить или создать `Label` для этого адреса
4. Вызвать `visitJumpInsn(IFEQ, label)` (IFEQ = if equals 0, т.е. if false)

**Результат:** Условный переход в JVM bytecode.

## Загрузка класса

### ByteArrayClassLoader

Для загрузки динамически сгенерированных классов используется специальный ClassLoader, который наследуется от `ClassLoader` и переопределяет метод `defineClass()`.

**Процесс загрузки:**
1. `defineClass(name, bytes)` принимает имя класса и массив байтов (JVM bytecode)
2. JVM загружает класс в память
3. JVM проверяет bytecode на корректность (валидация)
4. Класс становится доступным для использования через reflection

## Выполнение скомпилированного кода

### Вызов через reflection

`CompiledJVMFunction` содержит загруженный класс и метод, полученные через reflection. Метод `execute()` вызывает сгенерированный JVM bytecode через `method.invoke(null, frame, stack, mm)`.

**Что происходит при вызове:**
1. `method.invoke()` вызывает сгенерированный JVM bytecode
2. JVM интерпретирует bytecode (первый раз)
3. JVM компилирует в нативный код (JIT компиляция JVM)
4. Последующие вызовы выполняют нативный код напрямую

## Интеграция с VM

### Точки интеграции

VM проверяет наличие скомпилированной версии функции в двух точках:

1. **В начале интерпретации функции:**
   - Проверить, включен ли JIT
   - Получить скомпилированную версию через `getCompiled(functionName)`
   - Если существует → выполнить через `executeCompiled()`

2. **При вызове функции (CALL):**
   - Вызвать `recordCall(functionName)` для профилирования
   - Проверить наличие скомпилированной версии
   - Если существует → выполнить через `executeCompiled()`

### Выполнение скомпилированной функции

**Алгоритм:**
1. Вызвать `compiled.execute(frame, operandStack, memoryManager)` - это вызывает сгенерированный JVM bytecode
2. Проверить, завершилась ли функция (по `frame.pc`)
3. Если завершилась:
   - Удалить фрейм из `callStack`
   - Освободить все `ArrayRef` в `locals`
4. Вернуть результат выполнения

## Производительность

### Overhead компиляции

- **Время компиляции:** ~1-10 мс на функцию (один раз)
- **Память:** ~1-5 KB на скомпилированную функцию
- **Thread-safety:** Минимальный overhead благодаря `ConcurrentHashMap`

### Ускорение выполнения

После компиляции функции выполняются значительно быстрее:

- **Простые операции в циклах:** 50-100x быстрее интерпретации
- **Сложные функции с циклами:** 10-20x быстрее
- **Рекурсивные функции:** 5-10x быстрее

### Источники ускорения

1. **Устранение overhead интерпретации:**
   - Нет switch по opcode
   - Нет чтения байткода на каждую инструкцию
   - Прямое выполнение кода

2. **JVM оптимизации:**
   - Inlining методов
   - Loop unrolling
   - Dead code elimination
   - Bounds check elimination

3. **Нативная компиляция:**
   - JVM компилирует bytecode в машинный код
   - Оптимизации на уровне процессора

## Оптимизации JIT

### Возможные оптимизации

JIT компилятор может применять следующие оптимизации при трансляции:

1. **Peephole оптимизации:**
   - Устранение избыточных операций
   - Свертка констант

2. **Оптимизация циклов:**
   - Вынос инвариантов
   - Развертывание малых циклов

3. **Специализация:**
   - Специализация для конкретных типов
   - Оптимизация доступа к массивам

Однако основное ускорение обеспечивается JVM при выполнении сгенерированного bytecode.

## Обработка ошибок

### Ошибки компиляции

Если компиляция функции не удалась:
- Ошибка логируется в stderr
- Функция продолжает выполняться через интерпретацию
- Программа не падает

### Ошибки выполнения

Ошибки выполнения обрабатываются так же, как в интерпретации:
- Возвращается соответствующий `VMResult`
- Скомпилированный код должен проверять те же условия, что и интерпретатор

## Резюме

JIT компилятор автоматически определяет "горячие" функции и компилирует их в JVM bytecode для значительного ускорения выполнения. Компиляция выполняется асинхронно и не блокирует выполнение программы. Основное ускорение обеспечивается за счет устранения overhead интерпретации и оптимизаций JVM.

