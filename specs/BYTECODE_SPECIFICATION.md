# Спецификация байткода виртуальной машины

## Обзор

Байткод представляет собой низкоуровневое представление программы для выполнения на стековой виртуальной машине.

## Формат инструкций

### Структура

Каждая инструкция имеет фиксированный размер **4 байта (32 бита)**:

```
[OPCODE: 1 байт] [OPERAND: 3 байта]
```

- **OPCODE** (1 байт) - код операции (0x00-0xFF)
- **OPERAND** (3 байта) - операнд инструкции (максимальное значение: 16,777,215)

### Преимущества фиксированного формата

- ✅ Простой парсинг: читаем по 4 байта
- ✅ Простой интерпретатор: switch по opcode
- ✅ Легкая отладка: можно легко вычислить адрес любой инструкции

### Ограничения

- Максимальный размер операнда: 2²⁴ - 1 (16,777,215)
- Этого достаточно для индексов констант, локальных переменных и функций

## Представление значений

### Типы значений

Все значения на стеке представлены как tagged values:

```kotlin
sealed class Value {
    data class IntValue(val value: Long) : Value()      // 64-bit signed integer
    data class FloatValue(val value: Double) : Value()  // 64-bit IEEE 754 double
    data class BoolValue(val value: Boolean) : Value()   // boolean
    data class ArrayRef(val heapId: Int) : Value()       // ссылка на массив в куче
    object VoidValue : Value()                            // отсутствие значения
}
```

### Стек операндов

Используется один стек для всех типов значений:

```kotlin
val operandStack: Stack<Value> = Stack()
```

**Важно:** Проверки типов выполняются только на этапе семантического анализа. Во время выполнения VM полагается на корректность байткода и выполняет операции без дополнительных проверок типов.

## Набор инструкций

### Константы (0x00-0x0F)

#### PUSH_INT
- **Код:** `0x01`
- **Операнд:** индекс константы в `intConstants`
- **Описание:** Положить int константу на стек
- **Стек:** `... → ..., int_value`

#### PUSH_FLOAT
- **Код:** `0x02`
- **Операнд:** индекс константы в `floatConstants`
- **Описание:** Положить float константу на стек
- **Стек:** `... → ..., float_value`

#### PUSH_BOOL
- **Код:** `0x03`
- **Операнд:** `0` (false) или `1` (true)
- **Описание:** Положить bool значение на стек
- **Стек:** `... → ..., bool_value`

#### POP
- **Код:** `0x04`
- **Операнд:** игнорируется
- **Описание:** Удалить верхний элемент стека
- **Стек:** `..., value → ...`

### Локальные переменные (0x10-0x1F)

#### LOAD_LOCAL
- **Код:** `0x10`
- **Операнд:** индекс локальной переменной
- **Описание:** Загрузить значение локальной переменной на стек
- **Стек:** `... → ..., value`

#### STORE_LOCAL
- **Код:** `0x11`
- **Операнд:** индекс локальной переменной
- **Описание:** Сохранить значение со стека в локальную переменную
- **Стек:** `..., value → ...`

**Примечание:** Локальные переменные нумеруются начиная с 0. Параметры функции занимают первые индексы, затем идут локальные переменные.

### Арифметические операции - int (0x20-0x2F)

#### ADD_INT
- **Код:** `0x20`
- **Операнд:** игнорируется
- **Описание:** Сложение двух int значений
- **Стек:** `..., int_a, int_b → ..., int_result`

#### SUB_INT
- **Код:** `0x21`
- **Операнд:** игнорируется
- **Описание:** Вычитание двух int значений
- **Стек:** `..., int_a, int_b → ..., int_result`

#### MUL_INT
- **Код:** `0x22`
- **Операнд:** игнорируется
- **Описание:** Умножение двух int значений
- **Стек:** `..., int_a, int_b → ..., int_result`

#### DIV_INT
- **Код:** `0x23`
- **Операнд:** игнорируется
- **Описание:** Деление двух int значений
- **Стек:** `..., int_a, int_b → ..., int_result`
- **Ошибка:** Деление на ноль приводит к падению VM

#### MOD_INT
- **Код:** `0x24`
- **Операнд:** игнорируется
- **Описание:** Остаток от деления двух int значений
- **Стек:** `..., int_a, int_b → ..., int_result`
- **Ошибка:** Деление на ноль приводит к падению VM

#### NEG_INT
- **Код:** `0x25`
- **Операнд:** игнорируется
- **Описание:** Унарный минус для int
- **Стек:** `..., int_value → ..., int_result`

### Арифметические операции - float (0x30-0x3F)

#### ADD_FLOAT
- **Код:** `0x30`
- **Операнд:** игнорируется
- **Описание:** Сложение двух float значений
- **Стек:** `..., float_a, float_b → ..., float_result`

#### SUB_FLOAT
- **Код:** `0x31`
- **Операнд:** игнорируется
- **Описание:** Вычитание двух float значений
- **Стек:** `..., float_a, float_b → ..., float_result`

#### MUL_FLOAT
- **Код:** `0x32`
- **Операнд:** игнорируется
- **Описание:** Умножение двух float значений
- **Стек:** `..., float_a, float_b → ..., float_result`

#### DIV_FLOAT
- **Код:** `0x33`
- **Операнд:** игнорируется
- **Описание:** Деление двух float значений
- **Стек:** `..., float_a, float_b → ..., float_result`
- **Ошибка:** Деление на ноль приводит к падению VM

#### NEG_FLOAT
- **Код:** `0x35`
- **Операнд:** игнорируется
- **Описание:** Унарный минус для float
- **Стек:** `..., float_value → ..., float_result`

### Операции сравнения - int (0x40-0x4F)

Все операции сравнения возвращают `bool` значение на стек.

#### EQ_INT
- **Код:** `0x40`
- **Операнд:** игнорируется
- **Описание:** Проверка равенства двух int значений
- **Стек:** `..., int_a, int_b → ..., bool_result`

#### NE_INT
- **Код:** `0x41`
- **Операнд:** игнорируется
- **Описание:** Проверка неравенства двух int значений
- **Стек:** `..., int_a, int_b → ..., bool_result`

#### LT_INT
- **Код:** `0x42`
- **Операнд:** игнорируется
- **Описание:** Проверка "меньше" для двух int значений
- **Стек:** `..., int_a, int_b → ..., bool_result`

#### LE_INT
- **Код:** `0x43`
- **Операнд:** игнорируется
- **Описание:** Проверка "меньше или равно" для двух int значений
- **Стек:** `..., int_a, int_b → ..., bool_result`

#### GT_INT
- **Код:** `0x44`
- **Операнд:** игнорируется
- **Описание:** Проверка "больше" для двух int значений
- **Стек:** `..., int_a, int_b → ..., bool_result`

#### GE_INT
- **Код:** `0x45`
- **Операнд:** игнорируется
- **Описание:** Проверка "больше или равно" для двух int значений
- **Стек:** `..., int_a, int_b → ..., bool_result`

### Операции сравнения - float (0x50-0x5F)

Все операции сравнения возвращают `bool` значение на стек.

#### EQ_FLOAT
- **Код:** `0x50`
- **Операнд:** игнорируется
- **Описание:** Проверка равенства двух float значений
- **Стек:** `..., float_a, float_b → ..., bool_result`

#### NE_FLOAT
- **Код:** `0x51`
- **Операнд:** игнорируется
- **Описание:** Проверка неравенства двух float значений
- **Стек:** `..., float_a, float_b → ..., bool_result`

#### LT_FLOAT
- **Код:** `0x52`
- **Операнд:** игнорируется
- **Описание:** Проверка "меньше" для двух float значений
- **Стек:** `..., float_a, float_b → ..., bool_result`

#### LE_FLOAT
- **Код:** `0x53`
- **Операнд:** игнорируется
- **Описание:** Проверка "меньше или равно" для двух float значений
- **Стек:** `..., float_a, float_b → ..., bool_result`

#### GT_FLOAT
- **Код:** `0x54`
- **Операнд:** игнорируется
- **Описание:** Проверка "больше" для двух float значений
- **Стек:** `..., float_a, float_b → ..., bool_result`

#### GE_FLOAT
- **Код:** `0x55`
- **Операнд:** игнорируется
- **Описание:** Проверка "больше или равно" для двух float значений
- **Стек:** `..., float_a, float_b → ..., bool_result`

### Логические операции (0x60-0x6F)

#### AND
- **Код:** `0x60`
- **Операнд:** игнорируется
- **Описание:** Логическое И двух bool значений
- **Стек:** `..., bool_a, bool_b → ..., bool_result`

#### OR
- **Код:** `0x61`
- **Операнд:** игнорируется
- **Описание:** Логическое ИЛИ двух bool значений
- **Стек:** `..., bool_a, bool_b → ..., bool_result`

#### NOT
- **Код:** `0x62`
- **Операнд:** игнорируется
- **Описание:** Логическое НЕ для bool значения
- **Стек:** `..., bool_value → ..., bool_result`

### Управление потоком (0x70-0x7F)

#### JUMP
- **Код:** `0x70`
- **Операнд:** смещение в инструкциях (signed, может быть отрицательным)
- **Описание:** Безусловный переход
- **Стек:** не изменяется
- **Примечание:** Смещение указывается в количестве инструкций, а не байтов

#### JUMP_IF_FALSE
- **Код:** `0x71`
- **Операнд:** смещение в инструкциях (signed)
- **Описание:** Переход, если верхний элемент стека равен `false`
- **Стек:** `..., bool_value → ...` (значение удаляется со стека)

#### JUMP_IF_TRUE
- **Код:** `0x72`
- **Операнд:** смещение в инструкциях (signed)
- **Описание:** Переход, если верхний элемент стека равен `true`
- **Стек:** `..., bool_value → ...` (значение удаляется со стека)

### Функции (0x80-0x8F)

#### CALL
- **Код:** `0x80`
- **Операнд:** индекс функции в списке `functions` модуля
- **Описание:** Вызов функции
- **Стек:** `..., arg1, arg2, ..., argN → ..., return_value`
- **Примечание:** Аргументы должны быть на стеке в порядке объявления параметров. Функция должна вернуть значение на стек (или VoidValue для void функций).

#### RETURN
- **Код:** `0x81`
- **Операнд:** игнорируется
- **Описание:** Возврат из функции со значением
- **Стек:** `..., return_value → ...` (значение передается вызывающей функции)

#### RETURN_VOID
- **Код:** `0x82`
- **Операнд:** игнорируется
- **Описание:** Возврат из функции без значения
- **Стек:** не изменяется

### Массивы (0x90-0x9F)

#### NEW_ARRAY_INT
- **Код:** `0x90`
- **Операнд:** игнорируется
- **Описание:** Создать новый массив int на куче
- **Стек:** `..., int_size → ..., array_ref`
- **Примечание:** Размер массива должен быть на стеке. Массив инициализируется нулями.

#### NEW_ARRAY_FLOAT
- **Код:** `0x91`
- **Операнд:** игнорируется
- **Описание:** Создать новый массив float на куче
- **Стек:** `..., int_size → ..., array_ref`
- **Примечание:** Размер массива должен быть на стеке. Массив инициализируется нулями.

#### ARRAY_LOAD
- **Код:** `0x92`
- **Операнд:** игнорируется
- **Описание:** Загрузить элемент массива
- **Стек:** `..., array_ref, int_index → ..., element_value`
- **Ошибка:** Выход за границы массива приводит к падению VM

#### ARRAY_STORE
- **Код:** `0x93`
- **Операнд:** игнорируется
- **Описание:** Сохранить значение в элемент массива
- **Стек:** `..., array_ref, int_index, value → ...`
- **Ошибка:** Выход за границы массива приводит к падению VM

## Структура данных

### BytecodeModule

Корневая структура, представляющая скомпилированную программу:

```kotlin
data class BytecodeModule(
    val intConstants: List<Long>,           // Пул int констант
    val floatConstants: List<Double>,       // Пул float констант
    val functions: List<CompiledFunction>,  // Список скомпилированных функций
    val entryPoint: String                  // Имя функции точки входа ("main")
)
```

### CompiledFunction

Представляет одну скомпилированную функцию:

```kotlin
data class CompiledFunction(
    val name: String,                       // Имя функции
    val parameters: List<ParameterInfo>,    // Список параметров
    val returnType: TypeNode,               // Возвращаемый тип
    val localsCount: Int,                   // Количество локальных переменных
    val instructions: ByteArray,            // Байткод функции (массив байтов)
    val maxStackSize: Int                   // Максимальный размер стека операндов
)
```

**Примечания:**
- `localsCount` включает параметры функции
- `instructions` содержит байткод в формате массива байтов
- `maxStackSize` используется для проверки переполнения стека

### ParameterInfo

Информация о параметре функции:

```kotlin
data class ParameterInfo(
    val name: String,    // Имя параметра
    val type: TypeNode   // Тип параметра
)
```

## Генерация байткода

### Работа с пулами констант

Генератор байткода строит пулы констант во время компиляции. При встрече литерала в AST генератор:

1. **Проверяет наличие константы в пуле:**
   - Если константа уже есть в пуле → использует её индекс
   - Если константы нет → добавляет её в пул и запоминает новый индекс

2. **Генерирует инструкцию с индексом:**
   - Для `int` литерала → `PUSH_INT <index>`
   - Для `float` литерала → `PUSH_FLOAT <index>`
   - Для `bool` литерала → `PUSH_BOOL <0|1>` (без пула, значение прямо в операнде)

### Пример процесса генерации

**Исходный код:**
```kotlin
let x: int = 5 + 3;
let y: int = 5 + 10;
```

**Процесс генерации:**

1. Встречаем литерал `5`:
   - Пул пуст → добавляем `5` в `intConstants` с индексом 0
   - Генерируем: `PUSH_INT 0`

2. Встречаем литерал `3`:
   - Добавляем `3` в `intConstants` с индексом 1
   - Генерируем: `PUSH_INT 1`

3. Встречаем литерал `5` (второй раз):
   - Константа уже есть в пуле (индекс 0)
   - Генерируем: `PUSH_INT 0` (используем существующий индекс)

4. Встречаем литерал `10`:
   - Добавляем `10` в `intConstants` с индексом 2
   - Генерируем: `PUSH_INT 2`

**Результат:**
```kotlin
// Пул констант
intConstants = [5L, 3L, 10L]

// Байткод
PUSH_INT 0    // 5
PUSH_INT 1    // 3
ADD_INT
STORE_LOCAL 0 // x
PUSH_INT 0    // 5 (повторное использование)
PUSH_INT 2    // 10
ADD_INT
STORE_LOCAL 1 // y
```

### Реализация генератора

Генератор байткода может использовать следующую структуру для работы с пулами:

```kotlin
class BytecodeGenerator {
    // Временные пулы (строятся во время генерации)
    private val intConstants = mutableListOf<Long>()
    private val floatConstants = mutableListOf<Double>()
    private val constantIndices = mutableMapOf<Any, Int>()  // Кэш для быстрого поиска
    
    // Получить или добавить int константу
    fun getIntConstantIndex(value: Long): Int {
        return constantIndices.getOrPut(value) {
            val index = intConstants.size
            intConstants.add(value)
            index
        }
    }
    
    // Получить или добавить float константу
    fun getFloatConstantIndex(value: Double): Int {
        return constantIndices.getOrPut(value) {
            val index = floatConstants.size
            floatConstants.add(value)
            index
        }
    }
    
    // В конце генерации создаем BytecodeModule с финальными пулами
    fun buildModule(): BytecodeModule {
        return BytecodeModule(
            intConstants = intConstants.toList(),
            floatConstants = floatConstants.toList(),
            functions = compiledFunctions,
            entryPoint = "main"
        )
    }
}
```

**Важно:** Индексы констант определяются **во время генерации байткода**, а не во время выполнения. VM просто использует готовые индексы из инструкций.

## Примеры компиляции

### Пример 1: Простое присваивание

**Исходный код:**
```kotlin
let x: int = 5 + 3;
```

**Байткод:**
```
PUSH_INT 0      // 5 (индекс в intConstants)
PUSH_INT 1      // 3
ADD_INT
STORE_LOCAL 0   // x = локальная переменная #0
```

**Константы:**
```kotlin
intConstants = [5L, 3L]
```

### Пример 2: Условный оператор

**Исходный код:**
```kotlin
if (x > 10) {
    a = 1;
} else {
    a = 2;
}
```

**Байткод:**
```
LOAD_LOCAL 0    // x
PUSH_INT 2      // 10
GT_INT
JUMP_IF_FALSE 3 // пропустить then (3 инструкции вперед)
PUSH_INT 3      // 1
STORE_LOCAL 1   // a
JUMP 2          // пропустить else (2 инструкции вперед)
PUSH_INT 4      // 2
STORE_LOCAL 1   // a
```

**Константы:**
```kotlin
intConstants = [5L, 3L, 10L, 1L, 2L]
```

### Пример 3: Создание массива

**Исходный код:**
```kotlin
let arr: int[] = int[10];
```

**Байткод:**
```
PUSH_INT 0      // 10
NEW_ARRAY_INT
STORE_LOCAL 0   // arr
```

**Константы:**
```kotlin
intConstants = [10L]
```

### Пример 4: Доступ к массиву

**Исходный код:**
```kotlin
arr[0] = 42;
let first: int = arr[0];
```

**Байткод:**
```
LOAD_LOCAL 0    // arr
PUSH_INT 1      // 0
PUSH_INT 2      // 42
ARRAY_STORE     // arr, 0, 42 на стеке
LOAD_LOCAL 0    // arr
PUSH_INT 1      // 0
ARRAY_LOAD      // arr, 0 на стеке
STORE_LOCAL 1   // first
```

**Константы:**
```kotlin
intConstants = [10L, 0L, 42L]
```

### Пример 5: Вызов функции

**Исходный код:**
```kotlin
func factorial(n: int): int {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

func main(): void {
    let result: int = factorial(5);
}
```

**Байткод для `factorial`:**
```
LOAD_LOCAL 0    // n
PUSH_INT 0      // 1
LE_INT
JUMP_IF_FALSE 4 // пропустить return 1
PUSH_INT 0      // 1
RETURN
LOAD_LOCAL 0    // n
LOAD_LOCAL 0    // n
PUSH_INT 0      // 1
SUB_INT
CALL 0          // factorial (индекс функции)
MUL_INT
RETURN
```

**Байткод для `main`:**
```
PUSH_INT 1      // 5
CALL 0          // factorial (индекс функции)
STORE_LOCAL 0   // result
RETURN_VOID
```

**Константы:**
```kotlin
intConstants = [1L, 5L]
```

**Функции:**
```kotlin
functions = [
    CompiledFunction("factorial", ...),  // индекс 0
    CompiledFunction("main", ...)        // индекс 1
]
```

## Выполнение байткода

### Виртуальная машина

VM выполняет байткод следующим образом:

1. **Инициализация:**
   - Создается стек операндов
   - Создается стек вызовов (call stack)
   - Инициализируется куча для массивов

2. **Начало выполнения:**
   - Находится функция с именем `entryPoint` (обычно "main")
   - Создается первый call frame для этой функции
   - Устанавливается program counter (PC) на начало функции

3. **Интерпретация:**
   - Читается инструкция по адресу PC
   - Выполняется операция
   - PC увеличивается на 4 байта (размер инструкции)
   - Повторяется до достижения конца функции или RETURN

4. **Вызов функции:**
   - Аргументы берутся со стека операндов
   - Создается новый call frame
   - Локальные переменные инициализируются параметрами
   - PC устанавливается на начало вызываемой функции

5. **Возврат из функции:**
   - Возвращаемое значение (если есть) помещается на стек операндов
   - Восстанавливается предыдущий call frame
   - PC восстанавливается на инструкцию после CALL

### Call Frame

Каждый вызов функции создает новый call frame:

```kotlin
data class CallFrame(
    val function: CompiledFunction,
    val locals: Array<Value?>,      // Локальные переменные
    val returnAddress: Int           // Адрес возврата (PC)
)
```

**Примечание:** Параметры функции занимают первые индексы в массиве `locals`.

## Обработка ошибок

VM не выполняет проверки во время выполнения. Все ошибки приводят к немедленному падению:

- **Деление на ноль** → падение
- **Выход за границы массива** → падение
- **Переполнение стека** → падение
- **Недостаточно значений на стеке** → падение

Семантический анализатор должен гарантировать корректность программы до генерации байткода.

## Резюме

Байткод спроектирован для максимальной простоты реализации:

- ✅ Фиксированный размер инструкций (4 байта)
- ✅ Простая структура данных
- ✅ Прямолинейная генерация из AST
- ✅ Легкая интерпретация
- ✅ Один стек для всех типов значений
- ✅ Нет проверок типов во время выполнения

Этот дизайн позволяет быстро реализовать генератор байткода и интерпретатор, не беспокоясь об оптимизациях и компактности кода.

