# Спецификация DeadCodeEliminator

## Обзор

`DeadCodeEliminator` — иммутабельный проход-оптимизатор, выполняющий удаление мёртвого кода (Dead Code Elimination, DCE) по AST. Принимает `Program` и возвращает новый `Program`, в котором удалён или упрощён код, который никогда не повлияет на поведение программы, при этом **сохраняются побочные эффекты**.

**Интерфейс:**
```kotlin
object DeadCodeEliminator {
    fun eliminate(program: Program): Program
}
```

## Поддерживаемые преобразования

### 1. Удаление недостижимого кода

Внутри блока операторы, расположенные **после** первого `ReturnStmt`, удаляются.

### 2. Локальная DCE — backward liveness

Проход по операторам блока выполняется в обратном порядке. Собирается множество живых (used) переменных.

**Для каждого `VarDecl`:**
- Если переменная используется — декларация сохраняется
- Если переменная не используется и инициализатор чистый — декларация удаляется
- Если переменная не используется, но инициализатор имеет побочные эффекты — декларация преобразуется в `ExprStmt(init)`

**Для `ExprStmt`:**
- Выражение удаляется, если оно чистое (нет побочных эффектов)
- Иначе сохраняется и рекурсивно обрабатывается

**Для `IfStmt`/`ForStmt`/`BlockStmt`:**
- Выполняется рекурсивная обработка ветвей/тела

## Правила побочных эффектов

Выражения считаются **имеющими побочные эффекты**:
- `CallExpr` (вызовы функций)
- `AssignExpr` (присваивания)
- `ArrayInitExpr` (создание массива)
- `ArrayAccessExpr` (доступ по индексу — консервативно)

При отсутствии указанных побочных эффектов выражение считается чистым и может быть удалено, если его результат не используется.

## Алгоритм

1. `eliminate(program)`:
   - `removeUnreachableTopLevel` — удаление операторов после `return`
   - `processBlockStatements` — backward-liveness и локальная DCE

2. `processBlockStatements(stmts)`:
   - Идти по `stmts` в обратном порядке
   - Поддерживать `used: MutableSet<String>` — переменные, используемые *после* текущей позиции
   - Для каждого оператора обновлять `used` и формировать `result`

3. Вспомогательные функции:
   - `collectUsedVars(expr)` — собирает имена переменных, читаемых в выражении
   - `isSideEffectful(expr)` — определяет, есть ли в выражении побочный эффект

## Семантические детали

- **Консервативность:** оптимизатор консервативен — никогда не удаляет выражение с потенциальным побочным эффектом
- **Локальность анализа:** анализ выполняется внутри блока, нет глобальных оптимизаций
- **Функции и чистота:** все `CallExpr` считаются побочными

## Примеры

**Удаление unreachable:**
```kotlin
// Вход:
{
  x = 1;
  return 2;
  y = 3;   // unreachable
}

// Выход:
{
  x = 1;
  return 2;
}
```

**Удаление неиспользуемой чистой декларации:**
```kotlin
// Вход: let a: int = 1;
// Выход: (удалено)
```

**Сохранение побочного эффекта:**
```kotlin
// Вход: let a: int = f();
// Выход: f();
```

**If с чистым пустым телом:**
```kotlin
// Вход: if (true) { } else { }
// Выход: (удалено)
```
