# Спецификация `DeadCodeEliminator`

## Обзор

`DeadCodeEliminator` — иммутабельный проход-оптимизатор, выполняющий удаление мёртвого кода (Dead Code Elimination, DCE) по AST. Принимает `Program` и возвращает новый `Program`, в котором удалён или упрощён код, который никогда не повлияет на поведение программы, при этом **сохраняются побочные эффекты**.

**Цели:** уменьшить объём неверного/ненужного кода, удалить unreachable-код и локальные «dead stores», подготовить AST для дальнейших оптимизаций и генерации кода.

## Интерфейс

```kotlin
package com.compiler.parser.ast.optimizations

object DeadCodeEliminator {
    fun eliminate(program: Program): Program
}
```

`eliminate` — единственная публичная точка входа. Возвращает новый `Program` с применённой оптимизацией DCE.

## Поддерживаемые преобразования

1. **Удаление недостижимого кода (unreachable removal)**

   * Внутри блока `{ ... }` операторы, расположенные **после** первого `ReturnStmt`, удаляются (не сохраняются).
   * Это делается рекурсивно для вложенных блоков и функций.

2. **Локальная DCE — backward liveness (в пределах блока)**

   * Проход по операторам блока выполняется в обратном порядке.
   * Собирается множество живых (used) переменных, исходя из операторов, расположенных *после* текущей позиции.
   * Для каждого `VarDecl`:

     * Если объявляемая переменная содержится в множестве `used` — декларация сохраняется и её инициализатор рекурсивно оптимизируется.
     * Если переменная не используется и **инициализатор чистый** (без побочных эффектов) — декларация удаляется.
     * Если переменная не используется, но **инициализатор имеет побочные эффекты** — декларация преобразуется в `ExprStmt(init)` (чтобы сохранить побочный эффект).
   * Для `ExprStmt` — выражение удаляется, если оно чистое (нет чтений переменных и нет побочных эффектов); иначе сохраняется и рекурсивно обрабатывается.
   * Для `IfStmt`/`ForStmt`/`BlockStmt` — выполняется рекурсивная обработка ветвей/тела; требования по живым переменным объединяются корректно (ветвевой анализ).

3. **Обработка выражений**

   * При необходимости рекурсивно оптимизируются дочерние выражения (`processExpression`).
   * Результаты анализов (`collectUsedVars`, `isSideEffectful`) используются для принятия решения о сохранении/удалении операторов.

## Правила побочных эффектов

* Выражения считаются **имеющими побочные эффекты** (и поэтому не должны быть удалены):

  * `CallExpr` (вызовы функций)
  * `AssignExpr` (присваивания)
  * `ArrayInitExpr` (создание массива)
  * `ArrayAccessExpr` (доступ по индексу — консервативно, т.к. может выбрасывать исключение)
* При отсутствии указанных побочных эффектов выражение считается чистым и может быть удалено, если его результат не используется.
* Поведение можно сделать менее консервативным при наличии информации о чистоте конкретных функций.

## Обрабатываемые узлы AST — поведение

* `Program` — обрабатывается полностью: сначала убирается unreachable-код, затем выполняется локальная DCE по верхнеуровневым операторам.
* `BlockStmt` — сначала удаляются операторы после `return`, затем выполняется backward-liveness внутри блока.
* `VarDecl` — см. правило в разделе «Локальная DCE».
* `ExprStmt` — удаляется, если выражение чистое; иначе сохраняется (с рекурсивной обработкой).
* `ReturnStmt` — сохраняется; его значение обрабатывается рекурсивно и добавляет читаемые переменные в `used`.
* `IfStmt` — обе ветви обрабатываются отдельно; требование живых переменных перед `if` — объединение требований из обоих ветвей + переменные, используемые в условии. Если обе ветви пусты и условие чистое — `IfStmt` удаляется.
* `ForStmt` — инициализация (ForVarInit / ForExprInit / ForNoInit), условие, инкремент и тело обрабатываются рекурсивно. Цикл удаляется только если тело пусто *и* ни в init/cond/inc нет побочных эффектов.
* `FunctionDecl` — тело функции обрабатывается независимо; сама декларация функции сохраняется (функция — точка входа своей области).

## Алгоритм

1. `eliminate(program)`:

   * `removeUnreachableTopLevel` — проход по верхним операторам, удаление операторов после `return` в каждом блоке и рекурсивная подготовка блоков/функций/ветвей.
   * `processBlockStatements` — для получившегося списка верхнеуровневых операторов выполнить backward-liveness и локальную DCE.
2. `processBlockStatements(stmts)`:

   * Идти по `stmts` в обратном порядке (from last to first).
   * Поддерживать `used: MutableSet<String>` — переменные, используемые *после* текущей позиции.
   * Для каждого оператора обновлять `used` и формировать `result` (сохраняемые операторы).
   * В конце — вернуть `result.asReversed()` (восстановив исходный порядок).
3. Вспомогательные функции:

   * `collectUsedVars(expr)` — консервативно собирает имена переменных, читаемых в выражении (read), учитывает чтения в индексах/аргументах, не учитывает LValue как чтение при обычном присваивании (VariableExpr слева — запись).
   * `isSideEffectful(expr)` — консервативно определяет, есть ли в выражении побочный эффект (вызов, присваивание, обращение к массиву, создание массива).
   * `computeUsedBeforeForBlock(blockStmts, usedAfter)` — подобный backward-pass, но только вычисляет множество переменных, нужных до входа в блок, не меняя AST; используется при обработке ветвлений и вложенных блоков.

## Семантические детали и ограничения

* **Консервативность:** оптимизатор специально консервативен — никогда не удаляет выражение, которое потенциально имеет побочный эффект. Это уменьшает риск изменения семантики, но оставляет часть возможного DCE невыполненной.
* **Локальность анализа:** анализ выполняется внутри блока (и рекурсивно внутри функций), но **не** выполняются межфункциональные / межблочные (глобальные) оптимизации на основе полного графа потока или SSA. То есть нет глобального анализа использования переменных по всей программе.
* **Функции и чистота:** все `CallExpr` считаются побочными, даже если функции чистые. Можно интегрировать таблицу чистоты функций для более агрессивного удаления.
* **ArrayAccess как побочный эффект:** `ArrayAccessExpr` консервативно считается побочным (т.к. может бросить исключение). При наличии гарантии безопасности (внутренний анализ индексов/типов) поведение можно ослабить.
* **Позиции (`SourcePos`):** оптимизатор создает новые узлы (когда нужно) или копирует существующие; при преобразованиях позиция может сохраняться или меняться в зависимости от узла. Если требуется строгая корректность позиций для всех новых узлов — следует специально устанавливать `pos` при создании новых литералов/узлов.
* **Неинтегрированность с `ConstantFolder`:** DCE лучше применять **после** `ConstantFolder` (или в цепочке оптимизаций): many pure expressions will turn into literals and then DCE can remove dead declarations/exprs. Рекомендация: `val prog2 = DeadCodeEliminator.eliminate(ConstantFolder.fold(program))`.

## Примеры (input → output)

* Удаление unreachable:

  * Вход:

    ```
    {
      x = 1;
      return 2;
      y = 3;   // unreachable
    }
    ```

  * Выход:

    ```
    {
      x = 1;
      return 2;
    }
    ```

* Удаление неиспользуемой чистой декларации:

  * Вход:

    ```
    let a: int = 1;
    ```

  * Выход:

    ```
    (удалено)
    ```

* Сохранение побочного эффекта и удаление переменной:

  * Вход:

    ```
    let a: int = f();
    ```

  * Выход:

    ```
    f();
    ```

* If с чистым пустым телом:

  * Вход:

    ```
    if (true) { } else { }
    ```

  * Выход:

    ```
    (удалено)
    ```

* For с пустым телом и без побочных эффектов:
  * Вход:

    ```
    for (; true; ) { }
    ```

  * Выход:

    ```
    (удалено)
    ```

* For с побочным init:
  * Вход:

    ```
    for (initSide(); ; ) { }
    ```

  * Выход:

    ```
    for (initSide(); ; ) { }
    ```

## Примеры использования (Kotlin)

```kotlin
val parsed: Program = ... // AST от парсера
val optimized = DeadCodeEliminator.eliminate(folded)
```
