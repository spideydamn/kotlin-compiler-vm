name: Link PR to Issue by NOCOUNTRY key

on:
  pull_request:
    types: [opened, edited, reopened, synchronize, closed]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  prefix-title:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'reopened' || github.event.action == 'synchronize'
    steps:
      - name: Prefix PR title with branch name
        uses: actions/github-script@v7
        with:
          script: |
            // –ë–µ—Ä—ë–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ PR (–ø–æ—Å–ª–µ –ø—Ä–µ—Ñ–∏–∫—Å–∞—Ü–∏–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏–º job)
            const payloadPr = context.payload.pull_request;
            const { owner: repoOwner, repo: repoName } = context.repo;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: payloadPr.number });

            // Skip forks (token will not have write permissions)
            if (pr.head.repo.full_name !== pr.base.repo.full_name) {
              console.log("‚ö†Ô∏è PR is from a fork ‚Äî skipping title prefixing");
              return;
            }

            const { owner, repo } = context.repo;
            const branchName = pr.head.ref;
            const prefix = `${branchName}: `;

            if ((pr.title || "").startsWith(prefix)) {
              console.log("‚ÑπÔ∏è Title already prefixed with branch name");
              return;
            }

            const updatedTitle = `${prefix}${pr.title}`;
            await github.rest.pulls.update({
              owner: repoOwner,
              repo: repoName,
              pull_number: pr.number,
              title: updatedTitle
            });
            console.log(`‚úÖ Prefixed PR title with branch name: "${updatedTitle}"`);

  link:
    runs-on: ubuntu-latest
    needs: prefix-title
    if: github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'reopened' || github.event.action == 'synchronize'
    steps:
      - name: Link PR to issue
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;

            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º PR –∏–∑ fork ‚Äî –Ω–µ—Ç –ø—Ä–∞–≤ –ø–∏—Å–∞—Ç—å
            if (pr.head.repo.full_name !== pr.base.repo.full_name) {
              console.log("‚ö†Ô∏è PR is from a fork ‚Äî skipping linking");
              return;
            }

            // –ò—â–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –≤–∏–¥–∞ NOCOUNTRY-123 (–¥–æ–ø—É—Å–∫–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ –∏ —Ç–∏—Ä–µ)
            const match = pr.title.match(/\bNOCOUNTRY[-_‚Äì‚Äî ]?(\d+)\b/i);
            if (!match) {
              console.log("‚ùå No NOCOUNTRY-<number> found in PR title");
              return;
            }

            const issueNumber = match[1];
            const issueKey = `NOCOUNTRY-${issueNumber}`;

            // –ò—â–µ–º issue –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ —á–µ—Ä–µ–∑ Search API (—É—á–∏—Ç—ã–≤–∞–µ—Ç –∏ –æ—Ç–∫—Ä—ã—Ç—ã–µ, –∏ –∑–∞–∫—Ä—ã—Ç—ã–µ)
            const q = `repo:${context.repo.owner}/${context.repo.repo} is:issue in:title "${issueKey}"`;
            const search = await github.rest.search.issuesAndPullRequests({ q, per_page: 50 });
            const linkedIssue = search.data.items.find(i => i.title.startsWith(issueKey));
            if (!linkedIssue) {
              console.log(`‚ö†Ô∏è Issue with prefix ${issueKey} not found via search`);
              return;
            }

            // –ü—Ä–æ–≤–µ—Ä–∏–º, –Ω–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–∫–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è, —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ synchronize
            const existingComments = await github.paginate(
              github.rest.issues.listComments,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: linkedIssue.number,
                per_page: 100
              }
            );
            const hasComment = existingComments.some(c => (c.body || "").includes(`#${pr.number}`));
            if (!hasComment) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: linkedIssue.number,
                body: `üîó **–°–≤—è–∑–∞–Ω–Ω—ã–π PR:** [#${pr.number} - ${pr.title}](${pr.html_url})`
              });
            } else {
              console.log(`‚ÑπÔ∏è Comment already exists for PR #${pr.number} on issue #${linkedIssue.number}`);
            }

            // –û–±–Ω–æ–≤–∏–º –æ–ø–∏—Å–∞–Ω–∏–µ PR: –∑–∞–º–µ–Ω–∏–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Å—Ç—Ä–æ–∫—É, —á—Ç–æ–±—ã –Ω–µ –ø–ª–æ–¥–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã
            const markerRegex = /\*\*–°–≤—è–∑–∞–Ω–Ω–∞—è issue:\*\*\s*#\d+/i;
            const currentBody = pr.body || "";
            const desiredLine = `**–°–≤—è–∑–∞–Ω–Ω–∞—è issue:** #${linkedIssue.number}`;
            let updatedBody;
            if (markerRegex.test(currentBody)) {
              updatedBody = currentBody.replace(markerRegex, desiredLine);
            } else {
              updatedBody = `${currentBody}\n\n${desiredLine}`.trim();
            }

            if (updatedBody !== currentBody) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                body: updatedBody
              });
            } else {
              console.log("‚ÑπÔ∏è PR body already contains the correct linked issue line");
            }

            console.log(`‚úÖ Linked PR #${pr.number} ‚Üí Issue #${linkedIssue.number} (${issueKey})`);

  move-to-review:
    runs-on: ubuntu-latest
    needs: link
    if: github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'reopened' || github.event.action == 'synchronize'
    steps:
      - name: 'Put linked issue into Project "NoCountry lang" ‚Üí Status: Review'
        uses: actions/github-script@v7
        with:
          # –î–ª—è org-level –ø—Ä–æ–µ–∫—Ç–æ–≤ v2 –º–æ–∂–µ—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è PAT —Å –ø—Ä–∞–≤–∞–º–∏ –Ω–∞ projects
          # github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (pr.head.repo.full_name !== pr.base.repo.full_name) {
              console.log("‚ö†Ô∏è PR is from a fork ‚Äî skipping project move");
              return;
            }

            const { owner, repo } = context.repo;
            const PREFIX_REGEX = /\bNOCOUNTRY[-_‚Äì‚Äî ]?(\d+)\b/i;
            const match = pr.title.match(PREFIX_REGEX);
            if (!match) {
              console.log("‚ùå No NOCOUNTRY-<number> found in PR title");
              return;
            }
            const issueNumber = match[1];
            const issueKey = `NOCOUNTRY-${issueNumber}`;

            // –ù–∞—Ö–æ–¥–∏–º issue —á–µ—Ä–µ–∑ search –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É
            const search = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} is:issue in:title "${issueKey}"`,
              per_page: 50
            });
            const linkedIssue = search.data.items.find(i => i.title.startsWith(issueKey));
            if (!linkedIssue) {
              console.log(`‚ö†Ô∏è Issue with prefix ${issueKey} not found via search`);
              return;
            }
            const issueNodeId = linkedIssue.node_id;

            const PROJECT_TITLE = "NoCountry lang";
            const STATUS_NAME = "Status";
            const STATUS_VALUE = "Review";

            // –ò—â–µ–º –ø—Ä–æ–µ–∫—Ç v2 –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
            const repoProjects = await github.graphql(`
              query($owner:String!, $repo:String!, $query:String!){
                repository(owner:$owner, name:$repo){
                  projectsV2(first:50, query:$query){ nodes { id title fields(first:50){ nodes { ... on ProjectV2SingleSelectField { id name options { id name } } } } } }
                }
              }
            `, { owner, repo, query: PROJECT_TITLE });
            let project = repoProjects?.repository?.projectsV2?.nodes?.find(p => p.title === PROJECT_TITLE);

            if (!project) {
              console.log(`‚ùå Project v2 "${PROJECT_TITLE}" not found`);
              return;
            }

            const statusField = (project.fields.nodes || []).find(f => f && (f.name || "").toLowerCase() === STATUS_NAME.toLowerCase());
            if (!statusField) {
              console.log(`‚ùå Field "${STATUS_NAME}" not found in project`);
              return;
            }
            const reviewOption = (statusField.options || []).find(o => (o.name || "").toLowerCase() === STATUS_VALUE.toLowerCase());
            if (!reviewOption) {
              console.log(`‚ùå Option "${STATUS_VALUE}" for field "${STATUS_NAME}" not found`);
              return;
            }

            // –î–æ–±–∞–≤–ª—è–µ–º item –≤ –ø—Ä–æ–µ–∫—Ç (–∏–ª–∏ –Ω–∞—Ö–æ–¥–∏–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π)
            let itemId = null;
            try {
              const addRes = await github.graphql(`
                mutation($projectId:ID!, $contentId:ID!){
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } }
                }
              `, { projectId: project.id, contentId: issueNodeId });
              itemId = addRes?.addProjectV2ItemById?.item?.id || null;
            } catch (e) {
              console.log("‚ÑπÔ∏è Item may already exist in the project; trying to locate it");
            }

            if (!itemId) {
              const itemsQuery = await github.graphql(`
                query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      items(first:100){ nodes { id content { ... on Issue { id number } } } }
                    }
                  }
                }
              `, { projectId: project.id });
              const nodes = itemsQuery?.node?.items?.nodes || [];
              const found = nodes.find(n => n.content && n.content.id === issueNodeId);
              itemId = found?.id || null;
            }

            if (!itemId) {
              console.log("‚ùå Could not obtain project item id for the issue");
              return;
            }

            // –í—ã—Å—Ç–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å = Review
            await github.graphql(`
              mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!){
                updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ singleSelectOptionId:$optionId } }){ clientMutationId }
              }
            `, { projectId: project.id, itemId, fieldId: statusField.id, optionId: reviewOption.id });

            console.log(`‚úÖ Moved issue #${linkedIssue.number} to Project "${PROJECT_TITLE}" with Status "${STATUS_VALUE}"`);
  close-issue:
    runs-on: ubuntu-latest
    if: github.event.action == 'closed'
    steps:
      - name: Close linked issue on PR close/merge
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;

            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º PR –∏–∑ fork ‚Äî —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫ –ø—Ä–∞–≤
            if (pr.head.repo.full_name !== pr.base.repo.full_name) {
              console.log("‚ö†Ô∏è PR is from a fork ‚Äî skipping issue close");
              return;
            }

            const { owner, repo } = context.repo;

            // –ù–∞—Ö–æ–¥–∏–º –∫–ª—é—á NOCOUNTRY-<n> –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ PR
            const match = pr.title.match(/\bNOCOUNTRY[-_‚Äì‚Äî ]?(\d+)\b/i);
            if (!match) {
              console.log("‚ùå No NOCOUNTRY-<number> found in PR title");
              return;
            }

            const issueNumber = match[1];
            const issueKey = `NOCOUNTRY-${issueNumber}`;

            // –ò—â–µ–º issue –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏
            const q = `repo:${owner}/${repo} is:issue in:title "${issueKey}"`;
            const search = await github.rest.search.issuesAndPullRequests({ q, per_page: 50 });
            const linkedIssue = search.data.items.find(i => i.title.startsWith(issueKey));
            if (!linkedIssue) {
              console.log(`‚ö†Ô∏è Issue with prefix ${issueKey} not found via search`);
              return;
            }

            if (linkedIssue.state === 'closed') {
              console.log(`‚ÑπÔ∏è Issue #${linkedIssue.number} already closed`);
              return;
            }

            // –ó–∞–∫—Ä—ã–≤–∞–µ–º issue
            await github.rest.issues.update({
              owner,
              repo,
              issue_number: linkedIssue.number,
              state: 'closed'
            });

            // –î–æ–±–∞–≤–∏–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å –ø—Ä–∏—á–∏–Ω–æ–π
            const reason = pr.merged ? '–º–µ—Ä–¥–∂–µ–º PR' : '–∑–∞–∫—Ä—ã—Ç–∏–µ–º PR –±–µ–∑ –º–µ—Ä–¥–∂–∞';
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: linkedIssue.number,
              body: `‚úÖ –ó–∞–∫—Ä—ã—Ç–æ ${reason}: PR #${pr.number} (${pr.title})`
            });

            console.log(`‚úÖ Closed issue #${linkedIssue.number} due to PR #${pr.number} closed`);
